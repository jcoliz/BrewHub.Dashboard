//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ChartsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get summary chart of all device telemetry at the current moment
     * @return Chart.js data object
     */
    telemetry(): Promise<ChartConfig> {
        let url_ = this.baseUrl + "/api/Charts/Telemetry";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTelemetry(_response);
        });
    }

    protected processTelemetry(response: Response): Promise<ChartConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartConfig.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChartConfig>(null as any);
    }

    /**
     * Get telemetry for a single device, including all components
     * @param device Which device
     * @param timeframe Timeframe to covert
     * @return Chart.js data object
     */
    deviceChart(device: string, timeframe: TimeframeEnum): Promise<ChartConfig> {
        let url_ = this.baseUrl + "/api/Charts/{device}/Telemetry/{timeframe}";
        if (device === undefined || device === null)
            throw new Error("The parameter 'device' must be defined.");
        url_ = url_.replace("{device}", encodeURIComponent("" + device));
        if (timeframe === undefined || timeframe === null)
            throw new Error("The parameter 'timeframe' must be defined.");
        url_ = url_.replace("{timeframe}", encodeURIComponent("" + timeframe));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeviceChart(_response);
        });
    }

    protected processDeviceChart(response: Response): Promise<ChartConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartConfig.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChartConfig>(null as any);
    }

    /**
     * Get telemetry for a single component on a single device
     * @param device Which device
     * @param component Which component, or "device"
     * @param timeframe Timeframe to covert
     * @return Chart.js data object
     */
    componentChart(device: string, component: string, timeframe: TimeframeEnum): Promise<ChartConfig> {
        let url_ = this.baseUrl + "/api/Charts/{device}/Component/{component}/Telemetry/{timeframe}";
        if (device === undefined || device === null)
            throw new Error("The parameter 'device' must be defined.");
        url_ = url_.replace("{device}", encodeURIComponent("" + device));
        if (component === undefined || component === null)
            throw new Error("The parameter 'component' must be defined.");
        url_ = url_.replace("{component}", encodeURIComponent("" + component));
        if (timeframe === undefined || timeframe === null)
            throw new Error("The parameter 'timeframe' must be defined.");
        url_ = url_.replace("{timeframe}", encodeURIComponent("" + timeframe));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComponentChart(_response);
        });
    }

    protected processComponentChart(response: Response): Promise<ChartConfig> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChartConfig.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChartConfig>(null as any);
    }
}

export class DevicesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get list of all device names
     * @return Device names
     */
    devices(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDevices(_response);
        });
    }

    protected processDevices(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * Get summary slabs for all devices
     * @return Summaries
     */
    slabs(): Promise<DisplayMetricGroup[]> {
        let url_ = this.baseUrl + "/api/Devices/Slabs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSlabs(_response);
        });
    }

    protected processSlabs(response: Response): Promise<DisplayMetricGroup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DisplayMetricGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DisplayMetricGroup[]>(null as any);
    }

    /**
     * Get details for a single device
     * @param device Which device
     * @return Detail slabs, one for each component
     */
    device(device: string): Promise<DisplayMetricGroup[]> {
        let url_ = this.baseUrl + "/api/Devices/{device}";
        if (device === undefined || device === null)
            throw new Error("The parameter 'device' must be defined.");
        url_ = url_.replace("{device}", encodeURIComponent("" + device));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDevice(_response);
        });
    }

    protected processDevice(response: Response): Promise<DisplayMetricGroup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DisplayMetricGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DisplayMetricGroup[]>(null as any);
    }

    /**
     * Get details for a single component
     * @param device Which device
     * @param component Which component, or "device" for device details
     * @return Detail slabs, one for each kind of metric
     */
    component(device: string, component: string): Promise<DisplayMetricGroup[]> {
        let url_ = this.baseUrl + "/api/Devices/{device}/Component/{component}";
        if (device === undefined || device === null)
            throw new Error("The parameter 'device' must be defined.");
        url_ = url_.replace("{device}", encodeURIComponent("" + device));
        if (component === undefined || component === null)
            throw new Error("The parameter 'component' must be defined.");
        url_ = url_.replace("{component}", encodeURIComponent("" + component));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComponent(_response);
        });
    }

    protected processComponent(response: Response): Promise<DisplayMetricGroup[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DisplayMetricGroup.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DisplayMetricGroup[]>(null as any);
    }

    /**
     * Execute command on device
     * @param device Name of device
     * @param component Name of component, or "device"
     * @param command Name of command
     * @param payload Parameters to send to command
     */
    executeCommand(device: string, component: string, command: string, payload: any): Promise<void> {
        let url_ = this.baseUrl + "/api/Devices/{device}/Component/{component}/Command/{command}";
        if (device === undefined || device === null)
            throw new Error("The parameter 'device' must be defined.");
        url_ = url_.replace("{device}", encodeURIComponent("" + device));
        if (component === undefined || component === null)
            throw new Error("The parameter 'component' must be defined.");
        url_ = url_.replace("{component}", encodeURIComponent("" + component));
        if (command === undefined || command === null)
            throw new Error("The parameter 'command' must be defined.");
        url_ = url_.replace("{command}", encodeURIComponent("" + command));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteCommand(_response);
        });
    }

    protected processExecuteCommand(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Set property on device
     * @param payload Details for the property. Uses all fields except __Time
     */
    setProperty(payload: Datapoint): Promise<void> {
        let url_ = this.baseUrl + "/api/Devices/SetProperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payload);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetProperty(_response);
        });
    }

    protected processSetProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ScriptsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get list of all scripts
     * @return Device names
     */
    scripts(): Promise<Script[]> {
        let url_ = this.baseUrl + "/api/Scripts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScripts(_response);
        });
    }

    protected processScripts(response: Response): Promise<Script[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Script.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Script[]>(null as any);
    }
}

export class ChartConfig implements IChartConfig {
    type?: string | undefined;
    data?: ChartData | undefined;
    options?: ChartOptions | undefined;

    constructor(data?: IChartConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.data = _data["data"] ? ChartData.fromJS(_data["data"]) : <any>undefined;
            this.options = _data["options"] ? ChartOptions.fromJS(_data["options"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChartConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ChartConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["options"] = this.options ? this.options.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChartConfig {
    type?: string | undefined;
    data?: ChartData | undefined;
    options?: ChartOptions | undefined;
}

export class ChartData implements IChartData {
    labels?: string[] | undefined;
    datasets?: ChartDataSet[] | undefined;

    constructor(data?: IChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets!.push(ChartDataSet.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChartData {
        data = typeof data === 'object' ? data : {};
        let result = new ChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChartData {
    labels?: string[] | undefined;
    datasets?: ChartDataSet[] | undefined;
}

export class ChartDataSet implements IChartDataSet {
    label?: string | undefined;
    data?: number[] | undefined;
    backgroundColor?: string[] | undefined;
    borderColor?: string[] | undefined;
    borderWidth?: number | undefined;

    constructor(data?: IChartDataSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            if (Array.isArray(_data["backgroundColor"])) {
                this.backgroundColor = [] as any;
                for (let item of _data["backgroundColor"])
                    this.backgroundColor!.push(item);
            }
            if (Array.isArray(_data["borderColor"])) {
                this.borderColor = [] as any;
                for (let item of _data["borderColor"])
                    this.borderColor!.push(item);
            }
            this.borderWidth = _data["borderWidth"];
        }
    }

    static fromJS(data: any): ChartDataSet {
        data = typeof data === 'object' ? data : {};
        let result = new ChartDataSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        if (Array.isArray(this.backgroundColor)) {
            data["backgroundColor"] = [];
            for (let item of this.backgroundColor)
                data["backgroundColor"].push(item);
        }
        if (Array.isArray(this.borderColor)) {
            data["borderColor"] = [];
            for (let item of this.borderColor)
                data["borderColor"].push(item);
        }
        data["borderWidth"] = this.borderWidth;
        return data;
    }
}

export interface IChartDataSet {
    label?: string | undefined;
    data?: number[] | undefined;
    backgroundColor?: string[] | undefined;
    borderColor?: string[] | undefined;
    borderWidth?: number | undefined;
}

export class ChartOptions implements IChartOptions {
    plugins?: ChartPlugins | undefined;

    constructor(data?: IChartOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plugins = _data["plugins"] ? ChartPlugins.fromJS(_data["plugins"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChartOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plugins"] = this.plugins ? this.plugins.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChartOptions {
    plugins?: ChartPlugins | undefined;
}

export class ChartPlugins implements IChartPlugins {
    legend?: ChartLegend | undefined;

    constructor(data?: IChartPlugins) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legend = _data["legend"] ? ChartLegend.fromJS(_data["legend"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChartPlugins {
        data = typeof data === 'object' ? data : {};
        let result = new ChartPlugins();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legend"] = this.legend ? this.legend.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChartPlugins {
    legend?: ChartLegend | undefined;
}

export class ChartLegend implements IChartLegend {
    position?: string | undefined;
    display?: boolean;

    constructor(data?: IChartLegend) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.display = _data["display"];
        }
    }

    static fromJS(data: any): ChartLegend {
        data = typeof data === 'object' ? data : {};
        let result = new ChartLegend();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["display"] = this.display;
        return data;
    }
}

export interface IChartLegend {
    position?: string | undefined;
    display?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum TimeframeEnum {
    Minutes = 0,
    Hour = 1,
    Hours = 2,
    Day = 3,
    Week = 4,
    Month = 5,
}

export class DisplayMetricGroup implements IDisplayMetricGroup {
    title?: string;
    id?: string;
    model?: string;
    kind?: DisplayMetricGroupKind;
    telemetry?: DisplayMetric[];
    readOnlyProperties?: DisplayMetric[];
    writableProperties?: DisplayMetric[];
    commands?: DisplayMetric[];

    constructor(data?: IDisplayMetricGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.id = _data["id"];
            this.model = _data["model"];
            this.kind = _data["kind"];
            if (Array.isArray(_data["telemetry"])) {
                this.telemetry = [] as any;
                for (let item of _data["telemetry"])
                    this.telemetry!.push(DisplayMetric.fromJS(item));
            }
            if (Array.isArray(_data["readOnlyProperties"])) {
                this.readOnlyProperties = [] as any;
                for (let item of _data["readOnlyProperties"])
                    this.readOnlyProperties!.push(DisplayMetric.fromJS(item));
            }
            if (Array.isArray(_data["writableProperties"])) {
                this.writableProperties = [] as any;
                for (let item of _data["writableProperties"])
                    this.writableProperties!.push(DisplayMetric.fromJS(item));
            }
            if (Array.isArray(_data["commands"])) {
                this.commands = [] as any;
                for (let item of _data["commands"])
                    this.commands!.push(DisplayMetric.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DisplayMetricGroup {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayMetricGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["id"] = this.id;
        data["model"] = this.model;
        data["kind"] = this.kind;
        if (Array.isArray(this.telemetry)) {
            data["telemetry"] = [];
            for (let item of this.telemetry)
                data["telemetry"].push(item.toJSON());
        }
        if (Array.isArray(this.readOnlyProperties)) {
            data["readOnlyProperties"] = [];
            for (let item of this.readOnlyProperties)
                data["readOnlyProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.writableProperties)) {
            data["writableProperties"] = [];
            for (let item of this.writableProperties)
                data["writableProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.commands)) {
            data["commands"] = [];
            for (let item of this.commands)
                data["commands"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDisplayMetricGroup {
    title?: string;
    id?: string;
    model?: string;
    kind?: DisplayMetricGroupKind;
    telemetry?: DisplayMetric[];
    readOnlyProperties?: DisplayMetric[];
    writableProperties?: DisplayMetric[];
    commands?: DisplayMetric[];
}

export enum DisplayMetricGroupKind {
    Empty = 0,
    Device = 1,
    Component = 2,
    Grouping = 3,
}

export class DisplayMetric implements IDisplayMetric {
    name?: string;
    id?: string;
    value?: string;
    units?: string | undefined;

    constructor(data?: IDisplayMetric) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
            this.value = _data["value"];
            this.units = _data["units"];
        }
    }

    static fromJS(data: any): DisplayMetric {
        data = typeof data === 'object' ? data : {};
        let result = new DisplayMetric();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["value"] = this.value;
        data["units"] = this.units;
        return data;
    }
}

export interface IDisplayMetric {
    name?: string;
    id?: string;
    value?: string;
    units?: string | undefined;
}

export class Datapoint implements IDatapoint {
    __Device?: string;
    __Component?: string | undefined;
    __Model?: string;
    __Time?: Date;
    __Field?: string;
    __Value?: any;

    constructor(data?: IDatapoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.__Device = _data["__Device"];
            this.__Component = _data["__Component"];
            this.__Model = _data["__Model"];
            this.__Time = _data["__Time"] ? new Date(_data["__Time"].toString()) : <any>undefined;
            this.__Field = _data["__Field"];
            this.__Value = _data["__Value"];
        }
    }

    static fromJS(data: any): Datapoint {
        data = typeof data === 'object' ? data : {};
        let result = new Datapoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["__Device"] = this.__Device;
        data["__Component"] = this.__Component;
        data["__Model"] = this.__Model;
        data["__Time"] = this.__Time ? this.__Time.toISOString() : <any>undefined;
        data["__Field"] = this.__Field;
        data["__Value"] = this.__Value;
        return data;
    }
}

export interface IDatapoint {
    __Device?: string;
    __Component?: string | undefined;
    __Model?: string;
    __Time?: Date;
    __Field?: string;
    __Value?: any;
}

export class Script implements IScript {
    name?: string;
    environment?: string;
    version?: string;
    updated?: Date;

    constructor(data?: IScript) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.environment = _data["environment"];
            this.version = _data["version"];
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Script {
        data = typeof data === 'object' ? data : {};
        let result = new Script();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["environment"] = this.environment;
        data["version"] = this.version;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScript {
    name?: string;
    environment?: string;
    version?: string;
    updated?: Date;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}